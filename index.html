<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Quantum Computing Circuit Designer for Q#</title>
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">
    <style>
        /* https://codepen.io/jasonadelia/pen/DnrAe */
        html {
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #434343;
            background-image: linear-gradient(#434343, #282828);
        }

        pre {-moz-tab-size: 4;} /* Firefox */
        pre {tab-size: 4;} 

        #main {
            background-color: transparent;
            background-image: linear-gradient(0deg, transparent 24%, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, .05) 75%, rgba(255, 255, 255, .05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, .05) 75%, rgba(255, 255, 255, .05) 76%, transparent 77%, transparent);
            height: 100%;
            background-size: 100px 100px;
        }
        .qubit-line {
            border: 3px solid #222;
            position: absolute;
            width:90%;
        }

        .gate {
            background-color: #333;
            width: 46px; /* border 1px each side */
            height: 46px;
            border: 1px solid #666;
            font-family:Arial, Helvetica, sans-serif;
        }
        .gate:before {
            line-height: 46px;            
            display: flex;
            justify-content: center;
            align-items: center;
            color:#bbb;
            font-weight: 100;
        }
        .X:before {
            content:"X";
            font-size:2.5em;
        }
        .H:before {
            content: "H";
            font-size:2.5em;
        }
        .M:before {
            content: "M";
            font-size:2.5em;
        }
        /* maybe svg is better */
        /* https://editor.method.ac/ */
        .CNOT {
            height:1300px;
            background:none;
            border:none;
            background: linear-gradient(#676767 0% 100%);
            background-size: 5px 98px;
            background-repeat: no-repeat;
            background-position: 22px 20px;
        }
        .CNOT:before {
            content:"ᐧ";
            font-size:10.0em;
            margin-top:9px;            
            margin-bottom:16px;
            color:#bbb;
            margin-left:3px;
        }
        .CNOT:after {
            content:"⊕";
            font-size:4.3em;
            color:#bbb;
            margin-left:-1px;
        }

        .Q:before {
            content:"❘0⟩";
            font-size:1.8em;
        }
        .Q {
            background-color:#262626;
        }

        .navbar {
            border-bottom:1px solid darkgray;
            background:#444;
        }

    </style>
</head>

<body>
    <header class="navbar">
        <section class="navbar-section">
            <a href="..." class="navbar-brand mr-2 text-light ml-2">Quantum Computing Circuit Designer</a>
            <a class="btn ml-2" onClick="test()">Test to Add Some Gates</a>
        </section>
        <section class="navbar-section">
            <div class="input-group input-inline">
                <button class="btn" onClick="showExport()">Q# Code <i class="icon icon-resize-horiz"></i></button>
                <button id="export-button" class="btn" onClick="addQubit()">Add Qubit <i class="icon icon-plus"></i></button>
            </div>
        </section>
    </header>
    <div id="main">
    </div>
    <!-- EXPORT MODAL DIALOG -->
    <div class="modal " id="modal-export">
        <a href="#close" class="modal-overlay" onClick="hideExport()"></a>
        <div class="modal-container ">
          <div class="modal-header pt-3 pl-0 pr-0">
            <a href="#close" class="btn btn-clear float-right" onClick="hideExport()"></a>
            <div class="modal-title h5">Exported Q# Code</div>
          </div>
          <div class="modal-body pt-0 pl-0 pr-0">
            <div class="content">
                <pre class="code mt-0 " data-lang="Q#"><code id="code"></code></pre>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn" onClick="copyToClipboard()">Copy to Clipboard <i class="icon icon-link"></i></button>
          </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mobx/5.15.4/mobx.umd.min.js" integrity="sha256-UNmlC4kJptwCuBMr9TacFKVWt1u7VkOrJdpiu6SZseM=" crossorigin="anonymous"></script>
    <script>
        // draggable https://github.com/bcherny/draggable/
        !function (t, e) { "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : t.Draggable = e() }(this, function () { "use strict"; var t = { grid: 0, filterTarget: null, limit: { x: null, y: null }, threshold: 0, setCursor: !1, setPosition: !0, smoothDrag: !0, useGPU: !0, onDrag: u, onDragStart: u, onDragEnd: u }, e = { transform: function () { for (var t = " -o- -ms- -moz- -webkit-".split(" "), e = document.body.style, n = t.length; n--;) { var o = t[n] + "transform"; if (o in e) return o } }() }, n = { assign: function () { for (var t = arguments[0], e = arguments.length, n = 1; n < e; n++) { var o = arguments[n]; for (var i in o) t[i] = o[i] } return t }, bind: function (t, e) { return function () { t.apply(e, arguments) } }, on: function (t, e, o) { if (e && o) n.addEvent(t, e, o); else if (e) for (var i in e) n.addEvent(t, i, e[i]) }, off: function (t, e, o) { if (e && o) n.removeEvent(t, e, o); else if (e) for (var i in e) n.removeEvent(t, i, e[i]) }, limit: function (t, e) { return e instanceof Array ? t < (e = [+e[0], +e[1]])[0] ? t = e[0] : t > e[1] && (t = e[1]) : t = +e, t }, addEvent: "attachEvent" in Element.prototype ? function (t, e, n) { t.attachEvent("on" + e, n) } : function (t, e, n) { t.addEventListener(e, n, !1) }, removeEvent: "attachEvent" in Element.prototype ? function (t, e, n) { t.detachEvent("on" + e, n) } : function (t, e, n) { t.removeEventListener(e, n) } }; function o(e, o) { var i = this, r = n.bind(i.start, i), s = n.bind(i.drag, i), u = n.bind(i.stop, i); if (!a(e)) throw new TypeError("Draggable expects argument 0 to be an Element"); o = n.assign({}, t, o), n.assign(i, { element: e, handle: o.handle && a(o.handle) ? o.handle : e, handlers: { start: { mousedown: r, touchstart: r }, move: { mousemove: s, mouseup: u, touchmove: s, touchend: u } }, options: o }), i.initialize() } function i(t) { return parseInt(t, 10) } function r(t) { return "currentStyle" in t ? t.currentStyle : getComputedStyle(t) } function s(t) { return null != t } function a(t) { return t instanceof Element || "undefined" != typeof HTMLDocument && t instanceof HTMLDocument } function u() { } return n.assign(o.prototype, { setOption: function (t, e) { var n = this; return n.options[t] = e, n.initialize(), n }, get: function () { var t = this.dragEvent; return { x: t.x, y: t.y } }, set: function (t, e) { var n = this.dragEvent; return n.original = { x: n.x, y: n.y }, this.move(t, e), this }, dragEvent: { started: !1, x: 0, y: 0 }, initialize: function () { var t, o = this, i = o.element, s = (o.handle, i.style), a = r(i), u = o.options, f = e.transform, l = o._dimensions = { height: i.offsetHeight, left: i.offsetLeft, top: i.offsetTop, width: i.offsetWidth }; u.useGPU && f && ("none" === (t = a[f]) && (t = ""), s[f] = t + " translate3d(0,0,0)"), u.setPosition && (s.display = "block", s.left = l.left + "px", s.top = l.top + "px", s.width = l.width + "px", s.height = l.height + "px", s.bottom = s.right = "auto", s.margin = 0, s.position = "absolute"), u.setCursor && (s.cursor = "move"), o.setLimit(u.limit), n.assign(o.dragEvent, { x: l.left, y: l.top }), n.on(o.handle, o.handlers.start) }, start: function (t) { var e = this, o = e.getCursor(t), i = e.element; e.useTarget(t.target || t.srcElement) && (t.preventDefault && !t.target.getAttribute("contenteditable") ? t.preventDefault() : t.target.getAttribute("contenteditable") || (t.returnValue = !1), e.dragEvent.oldZindex = i.style.zIndex, i.style.zIndex = 1e4, e.setCursor(o), e.setPosition(), e.setZoom(), n.on(document, e.handlers.move)) }, drag: function (t) { var e = this, n = e.dragEvent, o = e.element, i = e._cursor, r = e._dimensions, s = e.options, a = r.zoom, u = e.getCursor(t), f = s.threshold, l = (u.x - i.x) / a + r.left, d = (u.y - i.y) / a + r.top; !n.started && f && Math.abs(i.x - u.x) < f && Math.abs(i.y - u.y) < f || (n.original || (n.original = { x: l, y: d }), n.started || (s.onDragStart(o, l, d, t), n.started = !0), e.move(l, d) && s.onDrag(o, n.x, n.y, t)) }, move: function (t, e) { var n = this, o = n.dragEvent, i = n.options, r = i.grid, s = n.element.style, a = n.limit(t, e, o.original.x, o.original.y); return !i.smoothDrag && r && (a = n.round(a, r)), (a.x !== o.x || a.y !== o.y) && (o.x = a.x, o.y = a.y, s.left = a.x + "px", s.top = a.y + "px", !0) }, stop: function (t) { var e, o = this, i = o.dragEvent, r = o.element, s = o.options, a = s.grid; n.off(document, o.handlers.move), r.style.zIndex = i.oldZindex, s.smoothDrag && a && (e = o.round({ x: i.x, y: i.y }, a), o.move(e.x, e.y), n.assign(o.dragEvent, e)), o.dragEvent.started && s.onDragEnd(r, i.x, i.y, t), o.reset() }, reset: function () { this.dragEvent.started = !1 }, round: function (t) { var e = this.options.grid; return { x: e * Math.round(t.x / e), y: e * Math.round(t.y / e) } }, getCursor: function (t) { return { x: (t.targetTouches ? t.targetTouches[0] : t).clientX, y: (t.targetTouches ? t.targetTouches[0] : t).clientY } }, setCursor: function (t) { this._cursor = t }, setLimit: function (t) { var e = this, o = function (t, e) { return { x: t, y: e } }; if (t instanceof Function) e.limit = t; else if (a(t)) { var i = e._dimensions, r = t.scrollHeight - i.height, u = t.scrollWidth - i.width; e.limit = function (t, e) { return { x: n.limit(t, [0, u]), y: n.limit(e, [0, r]) } } } else if (t) { var f = s(t.x), l = s(t.y); e.limit = f || l ? function (e, o) { return { x: f ? n.limit(e, t.x) : e, y: l ? n.limit(o, t.y) : o } } : o } else e.limit = o }, setPosition: function () { var t = this.element, e = t.style; n.assign(this._dimensions, { left: i(e.left) || t.offsetLeft, top: i(e.top) || t.offsetTop }) }, setZoom: function () { for (var t = this.element, e = 1; t = t.offsetParent;) { var n = r(t).zoom; if (n && "normal" !== n) { e = n; break } } this._dimensions.zoom = e }, useTarget: function (t) { var e = this.options.filterTarget; return !(e instanceof Function) || e(t) }, destroy: function () { n.off(this.handle, this.handlers.start), n.off(document, this.handlers.move) } }), o });
    </script>

    <script>
        let circuit = {
            labels: [
                {
                    text: 'Phase Query',
                    t:[1,2]
                },
                {
                    text: 'Oracle',
                    t:[3]
                },
                {
                    text: 'Measurement',
                    t:[4]
                }
            ],
            qubits: 2,
            gates:[
                {type:"Q",q:0, t:0},
                {type:"Q",q:1, t:0},
                // Deutch's Algorithm
                // Setup
                {type:"H",q:0, t:2},
                {type:"X",q:1, t:1},
                {type:"H",q:1, t:2},
                // Oracle e.g. Identity, balanced function
                {type:"CNOT",q:0, t:3, target:1},
                // Measure
                {type:"M",q:0, t:4},
                {type:"M",q:1, t:4}
            ]
        };
        let state = mobx.observable(circuit);

        let gridSize = 100;
        let offsetLeft = gridSize * 1;
        let offsetTop = gridSize * 1;

        mobx.autorun(function(reaction){
            clearMainArea();
            renderQubitLines(state.qubits);
            renderGates(state.gates);
        }, { delay: 100 });       

        function addGate(gate, idx){
            let gateElem = document.createElement("div");
            gateElem.className = "gate " + gate.type;
            gateElem.setAttribute('data-type',gate.type);
            gateElem.setAttribute('data-index',idx);
            gateElem.id = 'gate_' + idx;
            document.getElementById('main').appendChild(gateElem);

            let x = getX(gate.t);
            let y = getY(gate.q);

            let limX = null;
            let limY = null;

            let cursor = true;
            
            // can't move
            if (gate.type === 'Q'){
                limX = x;
                limY = y;
                cursor = false;
            }

            let options = {
                grid: gridSize,
                setCursor: cursor,
                smoothDrag:false,
                limit: {x:limX,y:limY},
                onDrag: update,
                onDragEnd: update
            };
            let drag = new Draggable(gateElem, options);
            drag.set(x,y);
        }

        function clearMainArea(){
            document.getElementById('main').innerHTML = '';
        }
        function renderQubitLines(qubits){
            let main = document.getElementById('main');
            for (let i=0; i<qubits; i++){
                let qubitLine = document.createElement('hr');
                qubitLine.className = 'qubit-line';
                qubitLine.style.left = (25 + offsetLeft) + 'px';
                qubitLine.style.top = (offsetTop + (i * gridSize) + 15) + 'px';
                main.appendChild(qubitLine);
            }
        }
        
        function renderGates(gates){
            gates.forEach((gate,idx) => {
                addGate(gate,idx);
            }); 
        }
        function update(element, x, y) {
            //console.log(x, y, getT(x), getQ(y), element.getAttribute('data-type'),element.getAttribute('data-index'),element);
            let idx = parseInt(element.getAttribute('data-index'));
            state.gates[idx].t = getT(x);
            state.gates[idx].q = getQ(y);
        }

        // translate evolution timeline t to screen coord x
        function getX(t){
            return offsetLeft + t * gridSize;
        }

        // translate qubits position q to screen coord y
        function getY(q) {
            return offsetTop + q * gridSize;
        }

        // translate screen coord x to evolution timeline t
        function getT(x){
            return (x - offsetLeft) / gridSize;
        }

        // translate screen coord y to qubits position q
        function getQ(y){
            return (y - offsetTop) / gridSize;
        }

        function exportQSharp(data){
            // sort labels by t = pos
            // sort gates by t
            let glines = [];
            for (let i=0; i<data?.gates?.length; i++){
                let gtype = data?.gates[i]?.type;
                let tpos = data?.gates[i]?.t;
                let qpos = data?.gates[i]?.q;
                if (!glines[tpos]) {
                    glines[tpos] = [];
                    // this will be inserted first
                    glines[tpos][0] = `// t=${tpos}`;
                }
                let func = '';
                if (gtype === 'Q'){
                    // do nothing
                }
                else if (gtype === 'CNOT'){
                    let target = data?.gates[i]?.target;
                    func = `CNOT(qubits[${qpos}],qubits[${target}]);`;
                }
                else {
                    func = `${gtype}(qubits[${qpos}]);`;

                }
                if (func){
                    glines[tpos][1+qpos] = func; // +1 reserved 1st one for comment
                }
            }


            let gatesCode = glines.filter((line)=>line.length > 1).map((line)=>{
                //console.log(line);
                return line.filter((seg)=>seg).map((seg)=>{
                    return seg;
                }).join('\n\t\t\t');
            }).join('\n\n\t\t\t');


            let usingCode = `
\t\tusing(qubits = Qubit[${data?.qubits}]){
\t\t\t${gatesCode}

\t\t\t//Reset All
\t\t\tfor(qb in qubits){
\t\t\t\tReset(qb);
\t\t\t}
\t\t}
`;
            let codeStr = `namespace MyCircuit {
\topen Microsoft.Quantum.Canon;
\topen Microsoft.Quantum.Intrinsic;
\topen Microsoft.Quantum.Convert;
\topen Microsoft.Quantum.Math;

\t@EntryPoint()
\toperation Main(): Unit{
${usingCode}
\t}
}
`;
            return codeStr;
        }
    
        function showExport(){
            document.getElementById("modal-export").classList.add('active');
            let code = exportQSharp(state);
            document.getElementById('code').innerHTML = code;
        }
        function hideExport() {
            document.getElementById("modal-export").classList.remove('active');
        }

        function copyToClipboard() {
            var input = document.createElement('textarea');
            input.innerHTML = document.getElementById('code').innerHTML;
            document.body.appendChild(input);
            input.select();
            var result = document.execCommand('copy');
            document.body.removeChild(input);
            return result;
        }

        function addQubit(){
            state.qubits = state.qubits + 1;
            state.gates.push({type:"Q",q:state.qubits-1, t:0});
        }

        function test(){
            state.gates.push({type:"X",q:-1, t:5});
            state.gates.push({type:"H",q:-1, t:6});
            state.gates.push({type:"M",q:-1, t:7});
        }
    </script>
</body>

</html>